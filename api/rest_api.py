import base64
import json
import os
import time
from http.server import HTTPServer, BaseHTTPRequestHandler

transactions = []        # Used for Linear Search comparison
transactions_dict = {}   # Used for efficient Dictionary Lookup comparison

def load_parsed_data():
    """Loads the JSON data generated by the  XML parser"""
    global transactions, transactions_dict
    if os.path.exists('transactions.json'):
        with open('transactions.json', 'r') as f:
            transactions = json.load(f)
            #  Map the list into a dictionary for fast lookup
            for txn in transactions:
                transactions_dict[txn['id']] = txn
        print(f" Loaded {len(transactions)} records into memory.")
    else:
        print("[!] Warning: transactions.json not found. Run the parser first.")

# API HANDLER
class APIHandler(BaseHTTPRequestHandler):
    
    def check_login(self):
        
        auth_header = self.headers.get('Authorization')
        if not auth_header:
            return False
        
        try:
            # Extract "Basic <base64_string>"
            parts = auth_header.split(' ', 1)
            if len(parts) != 2 or parts[0] != 'Basic':
                return False
            
            # Decode the credentials
            decoded = base64.b64decode(parts[1]).decode('utf-8')
            return decoded == "team5:ALU2025"
        except Exception:
            return False

    def do_GET(self):
        if not self.check_login():
            self.send_response(401)
            self.send_header('WWW-Authenticate', 'Basic realm="MoMo API"')
            self.end_headers()
            self.wfile.write(b'{"error": "Authentication Required"}')
            return

        # GET /transactions 
        if self.path == '/transactions':
            self._send_json(transactions)

        # GET /transactions/{id} 
        elif self.path.startswith('/transactions/'):
            try:
                txn_id = int(self.path.split('/')[-1])
                
                # DSA COMPARISON: We use the Dictionary for O(1) speed
                txn = transactions_dict.get(txn_id)
                
                if txn:
                    self._send_json(txn)
                else:
                    self.send_response(404)
                    self.end_headers()
            except ValueError:
                self.send_response(400)
                self.end_headers()

    def do_POST(self):
        if not self.check_login():
            self.send_response(401)
            self.end_headers()
            return

        try:
            content_length = int(self.headers.get('Content-Length', 0))
            body = self.rfile.read(content_length)
            new_txn = json.loads(body)

            # Generate unique ID
            new_id = len(transactions) + 1
            new_txn['id'] = new_id

            # Sync both storage methods
            transactions.append(new_txn)
            transactions_dict[new_id] = new_txn

            # Send success response
            self._send_json(new_txn, 201)
        except Exception as e:
            print(f"POST Error: {e}")
            self.send_response(400)
            self.end_headers()

    def _send_json(self, data, status=200):
        """Ultra-safe JSON sender to prevent Parse Errors"""
        response_body = json.dumps(data).encode('utf-8')
        
        self.send_response(status)
        self.send_header('Content-Type', 'application/json')
        self.send_header('Content-Length', str(len(response_body))) # Tells Postman when to stop listening
        self.send_header('Access-Control-Allow-Origin', '*') # Prevents browser blocks
        self.end_headers()
        
        self.wfile.write(response_body)

    def do_PUT(self):

        if not self.check_login():
            self.send_response(401)
            self.end_headers()
            return

        try:
            txn_id = int(self.path.split('/')[-1])
            content_length = int(self.headers['Content-Length'])
            updated_data = json.loads(self.rfile.read(content_length))

            # LINEAR SEARCH: 
            for txn in transactions:
                if txn['id'] == txn_id:
                    txn.update(updated_data)
                    transactions_dict[txn_id] = txn # Keep dict in sync
                    self._send_json(txn)
                    return
            
            self.send_response(404)
            self.end_headers()
        except Exception:
            self.send_response(400)
            self.end_headers()

    def do_DELETE(self):
    
        if not self.check_login():
            self.send_response(401)
            self.end_headers()
            return

        global transactions
        try:
            txn_id = int(self.path.split('/')[-1])
            if txn_id in transactions_dict:
                # Remove from both data structures
                transactions = [t for t in transactions if t['id'] != txn_id]
                del transactions_dict[txn_id]
                
                self.send_response(200)
                self.end_headers()
                self.wfile.write(json.dumps({"message": "Deleted"}).encode())
            else:
                self.send_response(404)
                self.end_headers()
        except Exception:
            self.send_response(400)
            self.end_headers()

    def _send_json(self, data, status=200):
        self.send_response(status)
        self.send_header('Content-Type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps(data).encode())

#Start the server
if __name__ == '__main__':
    load_parsed_data()
    server = HTTPServer(('localhost', 8000), APIHandler)
    print("MoMo REST API Server running on port 8000")
    print("Auth: team5:ALU2025")
    server.serve_forever()